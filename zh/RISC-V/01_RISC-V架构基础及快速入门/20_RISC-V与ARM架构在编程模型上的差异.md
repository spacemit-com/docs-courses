# 1. 指令集架构（ISA）

### **RISC-V：**

  开放性与模块化：RISC-V 是开源架构，支持基础指令集和可选扩展（如整数原子操作 A、浮点运算 F/D）

  固定指令长度：基础指令为 32 位（RV32），支持扩展为 RV64 和 RV128。压缩指令扩展（C）支持 16 位长度

  简化设计：去掉冗余和复杂指令，减少硬件设计成本

  不支持复杂条件指令：仅通过基本条件分支实现

**示例（RISC-V 汇编代码）：**
```
# 两个整数相加
addi t0, zero, 10    # 将立即数 10 加载到 t0
addi t1, zero, 20    # 将立即数 20 加载到 t1
add t2, t0, t1       # t2 = t0 + t1
```

### **ARM：**

  商业化设计：封闭式架构，需要许可证才能使用

  指令长度灵活：支持 ARM（32 位）和 Thumb（16 位）模式，ARMv8 引入 64 位支持

  丰富的条件指令：如条件跳转 B.EQ、条件执行（CMP，MOV.EQ）

  内建 SIMD 支持：如 NEON 扩展，适合多媒体处理

**示例（ARM 汇编代码）：**
```
# 两个整数相加
MOV R0, #10          # 将立即数 10 加载到 R0
MOV R1, #20          # 将立即数 20 加载到 R1
ADD R2, R0, R1       # R2 = R0 + R1
```

# 2. 寄存器设计

### **RISC-V：**

  通用寄存器集：32 个通用寄存器（x0-x31），x0 为常数 0，其余寄存器用于整数运算、地址计算等

  寄存器别名（ABI）：

      x10-x17：函数参数寄存器（a0-a7）
  
      x1：返回地址（ra）
  
      x2：堆栈指针（sp）

**示例：**
```
# RISC-V 函数调用
addi sp, sp, -16     # 分配堆栈空间
sw ra, 12(sp)        # 保存返回地址
addi a0, zero, 5     # 函数参数 a0 = 5
jal ra, my_function  # 调用函数
lw ra, 12(sp)        # 恢复返回地址
addi sp, sp, 16      # 回收堆栈空间
ret                  # 返回

my_function:
	addi a0, a0, 1   # a0 = a0 + 1
	ret              # 返回
```

### **ARM：**

  寄存器分组：16 个通用寄存器（R0-R15），R0-R12 用于普通操作，R13（SP）、R14（LR）、R15（PC）有特定功能

  状态寄存器：
  
      CPSR（Current Program Status Register）：存储条件标志、模式等状态信息

**示例：**
```
# ARM 函数调用
PUSH {LR}            # 保存返回地址
MOV R0, #5           # 函数参数 R0 = 5
BL my_function       # 调用函数
POP {PC}             # 恢复返回地址并返回

my_function:
	ADD R0, R0, #1   # R0 = R0 + 1
	BX LR            # 返回
```

# 3. 内存访问模型

### **RISC-V：**

  严格 Load/Store 模型：指令只能通过寄存器访问内存

  对齐要求：对齐错误通常会导致异常

  简化内存指令：

      LW：加载字
  
      SW：存储字

**示例：**
```
# 读取和存储内存
addi t0, zero, 0x1000  # t0 = 基地址 0x1000
lw t1, 0(t0)           # t1 = 内存地址 [t0] 的值
addi t1, t1, 1         # t1 = t1 + 1
sw t1, 0(t0)           # 将 t1 的值存回 [t0]
```

### **ARM：**
  丰富的内存指令：
  
      支持带偏移的加载（LDR R0, [R1, #4]）

      支持块加载/存储（LDMIA，STMIA）

  非对齐访问：部分模式支持非对齐操作，但性能较低

**示例：**
```
# 读取和存储内存
LDR R0, =0x1000       # R0 = 基地址 0x1000
LDR R1, [R0]          # R1 = 内存地址 [R0] 的值
ADD R1, R1, #1        # R1 = R1 + 1
STR R1, [R0]          # 将 R1 的值存回 [R0]
```

# 4. 特权模式与异常处理

### **RISC-V：**
- 特权模式：
  
  - 用户模式（U-mode）：普通程序运行
  
  - 超级模式（S-mode）：操作系统
  
  - 机器模式（M-mode）：最高权限

- 标准化异常寄存器：
  
  - mcause：异常原因
  
  - mepc：异常返回地址

**示例：**
```
# RISC-V 异常处理
csrr t0, mepc         # 获取异常地址
addi t0, t0, 4        # 设置返回地址
csrw mepc, t0         # 恢复异常地址
mret                  # 返回
```

### **ARM：**
#### 异常模式：

用户模式（User Mode）
  
中断模式（IRQ/FIQ）

系统模式（Supervisor）

#### 异常向量表：
通过固定表项处理异常

**示例：**
```
# ARM 异常处理
LDR R0, =0x8000       # 加载异常地址
LDMIA R0!, {R1-R3}    # 处理异常数据
BX LR                 # 返回
```

# 5. 软件生态和工具链

### **RISC-V：**

  开源工具链：GCC 和 LLVM

  调试器：支持 OpenOCD 和 GDB

  快速增长的社区支持

### **ARM：**

  成熟工具链：Keil、ARM Compiler

  生态完善：支持移动、嵌入式和高性能计算
